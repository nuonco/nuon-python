"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from nuon import errors, models, utils
from nuon._hooks import HookContext
from nuon.types import OptionalNullable, UNSET
from nuon.utils import get_security_from_env
from nuon.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional, Union
from typing_extensions import deprecated


class Installs(BaseSDK):
    r"""installs"""

    def get_app_installs(
        self,
        *,
        security: Union[
            models.GetAppInstallsSecurity, models.GetAppInstallsSecurityTypedDict
        ],
        app_id: str,
        q: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstall]:
        r"""get all installs for an app

        :param security:
        :param app_id: app ID
        :param q: search query
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAppInstallsRequest(
            app_id=app_id,
            q=q,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/apps/{app_id}/installs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAppInstallsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAppInstalls",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstall], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_app_installs_async(
        self,
        *,
        security: Union[
            models.GetAppInstallsSecurity, models.GetAppInstallsSecurityTypedDict
        ],
        app_id: str,
        q: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstall]:
        r"""get all installs for an app

        :param security:
        :param app_id: app ID
        :param q: search query
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAppInstallsRequest(
            app_id=app_id,
            q=q,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/apps/{app_id}/installs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAppInstallsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAppInstalls",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstall], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_install(
        self,
        *,
        security: Union[
            models.CreateInstallSecurity, models.CreateInstallSecurityTypedDict
        ],
        app_id: str,
        name: str,
        aws_account: Optional[
            Union[models.AwsAccount, models.AwsAccountTypedDict]
        ] = None,
        azure_account: Optional[
            Union[models.AzureAccount, models.AzureAccountTypedDict]
        ] = None,
        inputs: Optional[Dict[str, str]] = None,
        install_config: Optional[
            Union[
                models.HelpersCreateInstallConfigParams,
                models.HelpersCreateInstallConfigParamsTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstall:
        r"""create an app install

        :param security:
        :param app_id: app ID
        :param name:
        :param aws_account:
        :param azure_account:
        :param inputs:
        :param install_config:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallRequest(
            app_id=app_id,
            service_create_install_request=models.ServiceCreateInstallRequest(
                aws_account=utils.get_pydantic_model(
                    aws_account, Optional[models.AwsAccount]
                ),
                azure_account=utils.get_pydantic_model(
                    azure_account, Optional[models.AzureAccount]
                ),
                inputs=inputs,
                install_config=utils.get_pydantic_model(
                    install_config, Optional[models.HelpersCreateInstallConfigParams]
                ),
                name=name,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/apps/{app_id}/installs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateInstallSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstall, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_install_async(
        self,
        *,
        security: Union[
            models.CreateInstallSecurity, models.CreateInstallSecurityTypedDict
        ],
        app_id: str,
        name: str,
        aws_account: Optional[
            Union[models.AwsAccount, models.AwsAccountTypedDict]
        ] = None,
        azure_account: Optional[
            Union[models.AzureAccount, models.AzureAccountTypedDict]
        ] = None,
        inputs: Optional[Dict[str, str]] = None,
        install_config: Optional[
            Union[
                models.HelpersCreateInstallConfigParams,
                models.HelpersCreateInstallConfigParamsTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstall:
        r"""create an app install

        :param security:
        :param app_id: app ID
        :param name:
        :param aws_account:
        :param azure_account:
        :param inputs:
        :param install_config:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallRequest(
            app_id=app_id,
            service_create_install_request=models.ServiceCreateInstallRequest(
                aws_account=utils.get_pydantic_model(
                    aws_account, Optional[models.AwsAccount]
                ),
                azure_account=utils.get_pydantic_model(
                    azure_account, Optional[models.AzureAccount]
                ),
                inputs=inputs,
                install_config=utils.get_pydantic_model(
                    install_config, Optional[models.HelpersCreateInstallConfigParams]
                ),
                name=name,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/apps/{app_id}/installs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateInstallSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstall, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_workflow(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowSecurity,
            models.GetInstallWorkflowSecurityTypedDict,
        ],
        install_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""get an install workflow

        Return a workflow.


        :param security:
        :param install_workflow_id: install workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowRequest(
            install_workflow_id=install_workflow_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_workflow_async(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowSecurity,
            models.GetInstallWorkflowSecurityTypedDict,
        ],
        install_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""get an install workflow

        Return a workflow.


        :param security:
        :param install_workflow_id: install workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowRequest(
            install_workflow_id=install_workflow_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def update_install_workflow(
        self,
        *,
        security: Union[
            models.UpdateInstallWorkflowSecurity,
            models.UpdateInstallWorkflowSecurityTypedDict,
        ],
        install_workflow_id: str,
        approval_option: models.AppInstallApprovalOption,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""update an install workflow

        :param security:
        :param install_workflow_id: install workflow ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallWorkflowRequest(
            install_workflow_id=install_workflow_id,
            service_update_workflow_request=models.ServiceUpdateWorkflowRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/install-workflows/{install_workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateInstallWorkflowSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_workflow_request,
                False,
                False,
                "json",
                models.ServiceUpdateWorkflowRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstallWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def update_install_workflow_async(
        self,
        *,
        security: Union[
            models.UpdateInstallWorkflowSecurity,
            models.UpdateInstallWorkflowSecurityTypedDict,
        ],
        install_workflow_id: str,
        approval_option: models.AppInstallApprovalOption,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""update an install workflow

        :param security:
        :param install_workflow_id: install workflow ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallWorkflowRequest(
            install_workflow_id=install_workflow_id,
            service_update_workflow_request=models.ServiceUpdateWorkflowRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/install-workflows/{install_workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateInstallWorkflowSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_workflow_request,
                False,
                False,
                "json",
                models.ServiceUpdateWorkflowRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstallWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def cancel_install_workflow(
        self,
        *,
        security: Union[
            models.CancelInstallWorkflowSecurity,
            models.CancelInstallWorkflowSecurityTypedDict,
        ],
        install_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""cancel an ongoing install workflow

        :param security:
        :param install_workflow_id: install workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CancelInstallWorkflowRequest(
            install_workflow_id=install_workflow_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/install-workflows/{install_workflow_id}/cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CancelInstallWorkflowSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CancelInstallWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def cancel_install_workflow_async(
        self,
        *,
        security: Union[
            models.CancelInstallWorkflowSecurity,
            models.CancelInstallWorkflowSecurityTypedDict,
        ],
        install_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""cancel an ongoing install workflow

        :param security:
        :param install_workflow_id: install workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CancelInstallWorkflowRequest(
            install_workflow_id=install_workflow_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/install-workflows/{install_workflow_id}/cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CancelInstallWorkflowSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CancelInstallWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_workflow_steps(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowStepsSecurity,
            models.GetInstallWorkflowStepsSecurityTypedDict,
        ],
        install_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppWorkflowStep]:
        r"""get an install workflow step

        Return all steps for a workflow.


        :param security:
        :param install_workflow_id: install workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowStepsRequest(
            install_workflow_id=install_workflow_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}/steps",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowStepsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflowSteps",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppWorkflowStep], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_workflow_steps_async(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowStepsSecurity,
            models.GetInstallWorkflowStepsSecurityTypedDict,
        ],
        install_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppWorkflowStep]:
        r"""get an install workflow step

        Return all steps for a workflow.


        :param security:
        :param install_workflow_id: install workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowStepsRequest(
            install_workflow_id=install_workflow_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}/steps",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowStepsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflowSteps",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppWorkflowStep], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_workflow_step(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowStepSecurity,
            models.GetInstallWorkflowStepSecurityTypedDict,
        ],
        install_workflow_id: str,
        install_workflow_step_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStep:
        r"""get an install workflow step

        Return a single workflow step.


        :param security:
        :param install_workflow_id: workflow id
        :param install_workflow_step_id: step id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowStepRequest(
            install_workflow_id=install_workflow_id,
            install_workflow_step_id=install_workflow_step_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}/steps/{install_workflow_step_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowStepSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflowStep",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStep, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_workflow_step_async(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowStepSecurity,
            models.GetInstallWorkflowStepSecurityTypedDict,
        ],
        install_workflow_id: str,
        install_workflow_step_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStep:
        r"""get an install workflow step

        Return a single workflow step.


        :param security:
        :param install_workflow_id: workflow id
        :param install_workflow_step_id: step id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowStepRequest(
            install_workflow_id=install_workflow_id,
            install_workflow_step_id=install_workflow_step_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}/steps/{install_workflow_step_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowStepSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflowStep",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStep, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_workflow_step_approval(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowStepApprovalSecurity,
            models.GetInstallWorkflowStepApprovalSecurityTypedDict,
        ],
        install_workflow_id: str,
        install_workflow_step_id: str,
        approval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApproval:
        r"""get an install workflow step approval

        :param security:
        :param install_workflow_id: workflow id
        :param install_workflow_step_id: step id
        :param approval_id: approval id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowStepApprovalRequest(
            install_workflow_id=install_workflow_id,
            install_workflow_step_id=install_workflow_step_id,
            approval_id=approval_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}/steps/{install_workflow_step_id}/approvals/{approval_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowStepApprovalSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflowStepApproval",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStepApproval, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_workflow_step_approval_async(
        self,
        *,
        security: Union[
            models.GetInstallWorkflowStepApprovalSecurity,
            models.GetInstallWorkflowStepApprovalSecurityTypedDict,
        ],
        install_workflow_id: str,
        install_workflow_step_id: str,
        approval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApproval:
        r"""get an install workflow step approval

        :param security:
        :param install_workflow_id: workflow id
        :param install_workflow_step_id: step id
        :param approval_id: approval id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallWorkflowStepApprovalRequest(
            install_workflow_id=install_workflow_id,
            install_workflow_step_id=install_workflow_step_id,
            approval_id=approval_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/install-workflows/{install_workflow_id}/steps/{install_workflow_step_id}/approvals/{approval_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallWorkflowStepApprovalSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallWorkflowStepApproval",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStepApproval, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_install_workflow_step_approval_response(
        self,
        *,
        security: Union[
            models.CreateInstallWorkflowStepApprovalResponseSecurity,
            models.CreateInstallWorkflowStepApprovalResponseSecurityTypedDict,
        ],
        install_workflow_id: str,
        install_workflow_step_id: str,
        approval_id: str,
        note: Optional[str] = None,
        response_type: Optional[models.AppWorkflowStepResponseType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApprovalResponse:
        r"""deploy a build to an install

        :param security:
        :param install_workflow_id: workflow id
        :param install_workflow_step_id: step id
        :param approval_id: approval id
        :param note:
        :param response_type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallWorkflowStepApprovalResponseRequest(
            install_workflow_id=install_workflow_id,
            install_workflow_step_id=install_workflow_step_id,
            approval_id=approval_id,
            service_create_workflow_step_approval_response_request=models.ServiceCreateWorkflowStepApprovalResponseRequest(
                note=note,
                response_type=response_type,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/install-workflows/{install_workflow_id}/steps/{install_workflow_step_id}/approvals/{approval_id}/response",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallWorkflowStepApprovalResponseSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_workflow_step_approval_response_request,
                False,
                False,
                "json",
                models.ServiceCreateWorkflowStepApprovalResponseRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallWorkflowStepApprovalResponse",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppWorkflowStepApprovalResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_install_workflow_step_approval_response_async(
        self,
        *,
        security: Union[
            models.CreateInstallWorkflowStepApprovalResponseSecurity,
            models.CreateInstallWorkflowStepApprovalResponseSecurityTypedDict,
        ],
        install_workflow_id: str,
        install_workflow_step_id: str,
        approval_id: str,
        note: Optional[str] = None,
        response_type: Optional[models.AppWorkflowStepResponseType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApprovalResponse:
        r"""deploy a build to an install

        :param security:
        :param install_workflow_id: workflow id
        :param install_workflow_step_id: step id
        :param approval_id: approval id
        :param note:
        :param response_type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallWorkflowStepApprovalResponseRequest(
            install_workflow_id=install_workflow_id,
            install_workflow_step_id=install_workflow_step_id,
            approval_id=approval_id,
            service_create_workflow_step_approval_response_request=models.ServiceCreateWorkflowStepApprovalResponseRequest(
                note=note,
                response_type=response_type,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/install-workflows/{install_workflow_id}/steps/{install_workflow_step_id}/approvals/{approval_id}/response",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallWorkflowStepApprovalResponseSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_workflow_step_approval_response_request,
                False,
                False,
                "json",
                models.ServiceCreateWorkflowStepApprovalResponseRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallWorkflowStepApprovalResponse",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppWorkflowStepApprovalResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_org_installs(
        self,
        *,
        security: Union[
            models.GetOrgInstallsSecurity, models.GetOrgInstallsSecurityTypedDict
        ],
        offset: Optional[int] = 0,
        q: Optional[str] = None,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstall]:
        r"""get all installs for an org

        :param security:
        :param offset: offset of results to return
        :param q: search query to filter installs by name
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetOrgInstallsRequest(
            offset=offset,
            q=q,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetOrgInstallsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetOrgInstalls",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstall], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_org_installs_async(
        self,
        *,
        security: Union[
            models.GetOrgInstallsSecurity, models.GetOrgInstallsSecurityTypedDict
        ],
        offset: Optional[int] = 0,
        q: Optional[str] = None,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstall]:
        r"""get all installs for an org

        :param security:
        :param offset: offset of results to return
        :param q: search query to filter installs by name
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetOrgInstallsRequest(
            offset=offset,
            q=q,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetOrgInstallsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetOrgInstalls",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstall], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_sandbox_run(
        self,
        *,
        security: Union[
            models.GetInstallSandboxRunSecurity,
            models.GetInstallSandboxRunSecurityTypedDict,
        ],
        run_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallSandboxRun:
        r"""get an install sandbox run

        :param security:
        :param run_id: run ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallSandboxRunRequest(
            run_id=run_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/sandbox-runs/{run_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallSandboxRunSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallSandboxRun",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallSandboxRun, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_sandbox_run_async(
        self,
        *,
        security: Union[
            models.GetInstallSandboxRunSecurity,
            models.GetInstallSandboxRunSecurityTypedDict,
        ],
        run_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallSandboxRun:
        r"""get an install sandbox run

        :param security:
        :param run_id: run ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallSandboxRunRequest(
            run_id=run_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/sandbox-runs/{run_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallSandboxRunSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallSandboxRun",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallSandboxRun, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_stack(
        self,
        *,
        security: Union[
            models.GetInstallStackSecurity, models.GetInstallStackSecurityTypedDict
        ],
        stack_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallStack:
        r"""get an install stack by stack ID

        :param security:
        :param stack_id: stack ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStackRequest(
            stack_id=stack_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/stacks/{stack_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallStackSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallStack",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallStack, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_stack_async(
        self,
        *,
        security: Union[
            models.GetInstallStackSecurity, models.GetInstallStackSecurityTypedDict
        ],
        stack_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallStack:
        r"""get an install stack by stack ID

        :param security:
        :param stack_id: stack ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStackRequest(
            stack_id=stack_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/stacks/{stack_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallStackSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallStack",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallStack, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def delete_install(
        self,
        *,
        security: Union[
            models.DeleteInstallSecurity, models.DeleteInstallSecurityTypedDict
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""delete an install

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteInstallRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/v1/installs/{install_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.DeleteInstallSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def delete_install_async(
        self,
        *,
        security: Union[
            models.DeleteInstallSecurity, models.DeleteInstallSecurityTypedDict
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""delete an install

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteInstallRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v1/installs/{install_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.DeleteInstallSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install(
        self,
        *,
        security: Union[models.GetInstallSecurity, models.GetInstallSecurityTypedDict],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstall:
        r"""get an install

        Forget an install that has been deleted outside of nuon.

        This should only be used in cases where an install was broken in an unordinary way and needs to be manually deleted so the parent resources can be deleted.


        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstall, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_async(
        self,
        *,
        security: Union[models.GetInstallSecurity, models.GetInstallSecurityTypedDict],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstall:
        r"""get an install

        Forget an install that has been deleted outside of nuon.

        This should only be used in cases where an install was broken in an unordinary way and needs to be manually deleted so the parent resources can be deleted.


        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstall, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def update_install(
        self,
        *,
        security: Union[
            models.UpdateInstallSecurity, models.UpdateInstallSecurityTypedDict
        ],
        install_id: str,
        name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstall:
        r"""update an install

        :param security:
        :param install_id: app ID
        :param name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallRequest(
            install_id=install_id,
            service_update_install_request=models.ServiceUpdateInstallRequest(
                name=name,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/installs/{install_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.UpdateInstallSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_install_request,
                False,
                False,
                "json",
                models.ServiceUpdateInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstall, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def update_install_async(
        self,
        *,
        security: Union[
            models.UpdateInstallSecurity, models.UpdateInstallSecurityTypedDict
        ],
        install_id: str,
        name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstall:
        r"""update an install

        :param security:
        :param install_id: app ID
        :param name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallRequest(
            install_id=install_id,
            service_update_install_request=models.ServiceUpdateInstallRequest(
                name=name,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/installs/{install_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.UpdateInstallSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_install_request,
                False,
                False,
                "json",
                models.ServiceUpdateInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstall, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_action_workflows(
        self,
        *,
        security: Union[
            models.GetInstallActionWorkflowsSecurity,
            models.GetInstallActionWorkflowsSecurityTypedDict,
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallActionWorkflow]:
        r"""get an installs action workflows

        Get install action workflows.


        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallActionWorkflowsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/action-workflows",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallActionWorkflowsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallActionWorkflows",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                List[models.AppInstallActionWorkflow], http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_action_workflows_async(
        self,
        *,
        security: Union[
            models.GetInstallActionWorkflowsSecurity,
            models.GetInstallActionWorkflowsSecurityTypedDict,
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallActionWorkflow]:
        r"""get an installs action workflows

        Get install action workflows.


        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallActionWorkflowsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/action-workflows",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallActionWorkflowsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallActionWorkflows",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                List[models.AppInstallActionWorkflow], http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_action_workflow(
        self,
        *,
        security: Union[
            models.GetInstallActionWorkflowSecurity,
            models.GetInstallActionWorkflowSecurityTypedDict,
        ],
        install_id: str,
        action_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallActionWorkflow:
        r"""get an install action workflow

        Get an install action workflow.


        :param security:
        :param install_id: install ID
        :param action_workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallActionWorkflowRequest(
            install_id=install_id,
            action_workflow_id=action_workflow_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/action-workflows/{action_workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallActionWorkflowSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallActionWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallActionWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_action_workflow_async(
        self,
        *,
        security: Union[
            models.GetInstallActionWorkflowSecurity,
            models.GetInstallActionWorkflowSecurityTypedDict,
        ],
        install_id: str,
        action_workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallActionWorkflow:
        r"""get an install action workflow

        Get an install action workflow.


        :param security:
        :param install_id: install ID
        :param action_workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallActionWorkflowRequest(
            install_id=install_id,
            action_workflow_id=action_workflow_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/action-workflows/{action_workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallActionWorkflowSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallActionWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallActionWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_audit_logs(
        self,
        *,
        security: Union[
            models.GetInstallAuditLogsSecurity,
            models.GetInstallAuditLogsSecurityTypedDict,
        ],
        install_id: str,
        start: str,
        end: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bytes:
        r"""get install audit logs

        :param security:
        :param install_id: install ID
        :param start: start timestamp for audit log range
        :param end: end timestamp for audit log range
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallAuditLogsRequest(
            install_id=install_id,
            start=start,
            end=end,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/audit_logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/csv",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallAuditLogsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallAuditLogs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/csv"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return http_res_bytes
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_audit_logs_async(
        self,
        *,
        security: Union[
            models.GetInstallAuditLogsSecurity,
            models.GetInstallAuditLogsSecurityTypedDict,
        ],
        install_id: str,
        start: str,
        end: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bytes:
        r"""get install audit logs

        :param security:
        :param install_id: install ID
        :param start: start timestamp for audit log range
        :param end: end timestamp for audit log range
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallAuditLogsRequest(
            install_id=install_id,
            start=start,
            end=end,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/audit_logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/csv",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallAuditLogsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallAuditLogs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/csv"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return http_res_bytes
        if utils.match_response(http_res, ["400", "401", "403", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_components(
        self,
        *,
        security: Union[
            models.GetInstallComponentsSecurity,
            models.GetInstallComponentsSecurityTypedDict,
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallComponent]:
        r"""get an installs components

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_components_async(
        self,
        *,
        security: Union[
            models.GetInstallComponentsSecurity,
            models.GetInstallComponentsSecurityTypedDict,
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallComponent]:
        r"""get an installs components

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def deploy_install_components(
        self,
        *,
        security: Union[
            models.DeployInstallComponentsSecurity,
            models.DeployInstallComponentsSecurityTypedDict,
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""deploy all components on an install

        Deploy all components to an install.

        This walks the graph order of the install's app, and will trigger a deploy for each on the specified install.


        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeployInstallComponentsRequest(
            install_id=install_id,
            service_deploy_install_components_request=models.ServiceDeployInstallComponentsRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/components/deploy-all",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeployInstallComponentsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_deploy_install_components_request,
                False,
                True,
                "json",
                Optional[models.ServiceDeployInstallComponentsRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeployInstallComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def deploy_install_components_async(
        self,
        *,
        security: Union[
            models.DeployInstallComponentsSecurity,
            models.DeployInstallComponentsSecurityTypedDict,
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""deploy all components on an install

        Deploy all components to an install.

        This walks the graph order of the install's app, and will trigger a deploy for each on the specified install.


        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeployInstallComponentsRequest(
            install_id=install_id,
            service_deploy_install_components_request=models.ServiceDeployInstallComponentsRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/components/deploy-all",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeployInstallComponentsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_deploy_install_components_request,
                False,
                True,
                "json",
                Optional[models.ServiceDeployInstallComponentsRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeployInstallComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_components_summary(
        self,
        *,
        security: Union[
            models.GetInstallComponentsSummarySecurity,
            models.GetInstallComponentsSummarySecurityTypedDict,
        ],
        install_id: str,
        types: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        q: Optional[str] = None,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallComponentSummary]:
        r"""get an installs components summary

        :param security:
        :param install_id: install ID
        :param types: component types to filter by
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param q: search query for component name
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentsSummaryRequest(
            install_id=install_id,
            types=types,
            offset=offset,
            limit=limit,
            page=page,
            q=q,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/components/summary",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentsSummarySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentsSummary",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                List[models.AppInstallComponentSummary], http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_components_summary_async(
        self,
        *,
        security: Union[
            models.GetInstallComponentsSummarySecurity,
            models.GetInstallComponentsSummarySecurityTypedDict,
        ],
        install_id: str,
        types: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        q: Optional[str] = None,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallComponentSummary]:
        r"""get an installs components summary

        :param security:
        :param install_id: install ID
        :param types: component types to filter by
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param q: search query for component name
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentsSummaryRequest(
            install_id=install_id,
            types=types,
            offset=offset,
            limit=limit,
            page=page,
            q=q,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/components/summary",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentsSummarySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentsSummary",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                List[models.AppInstallComponentSummary], http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def teardown_install_components(
        self,
        *,
        security: Union[
            models.TeardownInstallComponentsSecurity,
            models.TeardownInstallComponentsSecurityTypedDict,
        ],
        install_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""teardown an install's components

        Teardown all components on an install.


        :param security:
        :param install_id: install ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TeardownInstallComponentsRequest(
            install_id=install_id,
            service_teardown_install_components_request=models.ServiceTeardownInstallComponentsRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/components/teardown-all",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.TeardownInstallComponentsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_teardown_install_components_request,
                False,
                False,
                "json",
                models.ServiceTeardownInstallComponentsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="TeardownInstallComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def teardown_install_components_async(
        self,
        *,
        security: Union[
            models.TeardownInstallComponentsSecurity,
            models.TeardownInstallComponentsSecurityTypedDict,
        ],
        install_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""teardown an install's components

        Teardown all components on an install.


        :param security:
        :param install_id: install ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TeardownInstallComponentsRequest(
            install_id=install_id,
            service_teardown_install_components_request=models.ServiceTeardownInstallComponentsRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/components/teardown-all",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.TeardownInstallComponentsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_teardown_install_components_request,
                False,
                False,
                "json",
                models.ServiceTeardownInstallComponentsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="TeardownInstallComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_component(
        self,
        *,
        security: Union[
            models.GetInstallComponentSecurity,
            models.GetInstallComponentSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallComponent:
        r"""get an install component

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentRequest(
            install_id=install_id,
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_component_async(
        self,
        *,
        security: Union[
            models.GetInstallComponentSecurity,
            models.GetInstallComponentSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallComponent:
        r"""get an install component

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentRequest(
            install_id=install_id,
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_component_deploys(
        self,
        *,
        security: Union[
            models.GetInstallComponentDeploysSecurity,
            models.GetInstallComponentDeploysSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallDeploy]:
        r"""get an install components deploys

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentDeploysRequest(
            install_id=install_id,
            component_id=component_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}/deploys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentDeploysSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentDeploys",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallDeploy], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_component_deploys_async(
        self,
        *,
        security: Union[
            models.GetInstallComponentDeploysSecurity,
            models.GetInstallComponentDeploysSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallDeploy]:
        r"""get an install components deploys

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentDeploysRequest(
            install_id=install_id,
            component_id=component_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}/deploys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentDeploysSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentDeploys",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallDeploy], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_component_latest_deploy(
        self,
        *,
        security: Union[
            models.GetInstallComponentLatestDeploySecurity,
            models.GetInstallComponentLatestDeploySecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""get the latest deploy for an install component

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentLatestDeployRequest(
            install_id=install_id,
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}/deploys/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentLatestDeploySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentLatestDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_component_latest_deploy_async(
        self,
        *,
        security: Union[
            models.GetInstallComponentLatestDeploySecurity,
            models.GetInstallComponentLatestDeploySecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""get the latest deploy for an install component

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentLatestDeployRequest(
            install_id=install_id,
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}/deploys/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentLatestDeploySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentLatestDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_component_outputs(
        self,
        *,
        security: Union[
            models.GetInstallComponentOutputsSecurity,
            models.GetInstallComponentOutputsSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, Any]:
        r"""get an install component outputs

        Return the latest outputs for a component.

        **NOTE** requires a valid install.


        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentOutputsRequest(
            install_id=install_id,
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}/outputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentOutputsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentOutputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, Any], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_component_outputs_async(
        self,
        *,
        security: Union[
            models.GetInstallComponentOutputsSecurity,
            models.GetInstallComponentOutputsSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, Any]:
        r"""get an install component outputs

        Return the latest outputs for a component.

        **NOTE** requires a valid install.


        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallComponentOutputsRequest(
            install_id=install_id,
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/components/{component_id}/outputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallComponentOutputsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallComponentOutputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, Any], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def teardown_install_component(
        self,
        *,
        security: Union[
            models.TeardownInstallComponentSecurity,
            models.TeardownInstallComponentSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""teardown an install component

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TeardownInstallComponentRequest(
            install_id=install_id,
            component_id=component_id,
            service_teardown_install_component_request=models.ServiceTeardownInstallComponentRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/components/{component_id}/teardown",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.TeardownInstallComponentSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_teardown_install_component_request,
                False,
                True,
                "json",
                Optional[models.ServiceTeardownInstallComponentRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="TeardownInstallComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def teardown_install_component_async(
        self,
        *,
        security: Union[
            models.TeardownInstallComponentSecurity,
            models.TeardownInstallComponentSecurityTypedDict,
        ],
        install_id: str,
        component_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""teardown an install component

        :param security:
        :param install_id: install ID
        :param component_id: component ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TeardownInstallComponentRequest(
            install_id=install_id,
            component_id=component_id,
            service_teardown_install_component_request=models.ServiceTeardownInstallComponentRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/components/{component_id}/teardown",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.TeardownInstallComponentSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_teardown_install_component_request,
                False,
                True,
                "json",
                Optional[models.ServiceTeardownInstallComponentRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="TeardownInstallComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_install_config(
        self,
        *,
        security: Union[
            models.CreateInstallConfigSecurity,
            models.CreateInstallConfigSecurityTypedDict,
        ],
        install_id: str,
        approval_option: Optional[models.AppInstallApprovalOption] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallConfig:
        r"""create an install config

        :param security:
        :param install_id: install ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallConfigRequest(
            install_id=install_id,
            service_create_install_config_request=models.ServiceCreateInstallConfigRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/configs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_config_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_install_config_async(
        self,
        *,
        security: Union[
            models.CreateInstallConfigSecurity,
            models.CreateInstallConfigSecurityTypedDict,
        ],
        install_id: str,
        approval_option: Optional[models.AppInstallApprovalOption] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallConfig:
        r"""create an install config

        :param security:
        :param install_id: install ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallConfigRequest(
            install_id=install_id,
            service_create_install_config_request=models.ServiceCreateInstallConfigRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/configs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_config_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def update_install_config(
        self,
        *,
        security: Union[
            models.UpdateInstallConfigSecurity,
            models.UpdateInstallConfigSecurityTypedDict,
        ],
        install_id: str,
        config_id: str,
        approval_option: Optional[models.AppInstallApprovalOption] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallConfig:
        r"""create an install config

        :param security:
        :param install_id: install ID
        :param config_id: config ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallConfigRequest(
            install_id=install_id,
            config_id=config_id,
            service_update_install_config_request=models.ServiceUpdateInstallConfigRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/installs/{install_id}/configs/{config_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateInstallConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_install_config_request,
                False,
                False,
                "json",
                models.ServiceUpdateInstallConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstallConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def update_install_config_async(
        self,
        *,
        security: Union[
            models.UpdateInstallConfigSecurity,
            models.UpdateInstallConfigSecurityTypedDict,
        ],
        install_id: str,
        config_id: str,
        approval_option: Optional[models.AppInstallApprovalOption] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallConfig:
        r"""create an install config

        :param security:
        :param install_id: install ID
        :param config_id: config ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallConfigRequest(
            install_id=install_id,
            config_id=config_id,
            service_update_install_config_request=models.ServiceUpdateInstallConfigRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/installs/{install_id}/configs/{config_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateInstallConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_install_config_request,
                False,
                False,
                "json",
                models.ServiceUpdateInstallConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstallConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_deploys(
        self,
        *,
        security: Union[
            models.GetInstallDeploysSecurity, models.GetInstallDeploysSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallDeploy]:
        r"""get all deploys to an install

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallDeploysRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/deploys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallDeploysSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallDeploys",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallDeploy], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_deploys_async(
        self,
        *,
        security: Union[
            models.GetInstallDeploysSecurity, models.GetInstallDeploysSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallDeploy]:
        r"""get all deploys to an install

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallDeploysRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/deploys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallDeploysSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallDeploys",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallDeploy], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_install_deploy(
        self,
        *,
        security: Union[
            models.CreateInstallDeploySecurity,
            models.CreateInstallDeploySecurityTypedDict,
        ],
        install_id: str,
        build_id: Optional[str] = None,
        deploy_dependents: Optional[bool] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""deploy a build to an install

        :param security:
        :param install_id: install ID
        :param build_id:
        :param deploy_dependents:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallDeployRequest(
            install_id=install_id,
            service_create_install_deploy_request=models.ServiceCreateInstallDeployRequest(
                build_id=build_id,
                deploy_dependents=deploy_dependents,
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/deploys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallDeploySecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_deploy_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallDeployRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_install_deploy_async(
        self,
        *,
        security: Union[
            models.CreateInstallDeploySecurity,
            models.CreateInstallDeploySecurityTypedDict,
        ],
        install_id: str,
        build_id: Optional[str] = None,
        deploy_dependents: Optional[bool] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""deploy a build to an install

        :param security:
        :param install_id: install ID
        :param build_id:
        :param deploy_dependents:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallDeployRequest(
            install_id=install_id,
            service_create_install_deploy_request=models.ServiceCreateInstallDeployRequest(
                build_id=build_id,
                deploy_dependents=deploy_dependents,
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/deploys",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallDeploySecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_deploy_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallDeployRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_latest_deploy(
        self,
        *,
        security: Union[
            models.GetInstallLatestDeploySecurity,
            models.GetInstallLatestDeploySecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""get an install deploy

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallLatestDeployRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/deploys/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallLatestDeploySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallLatestDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_latest_deploy_async(
        self,
        *,
        security: Union[
            models.GetInstallLatestDeploySecurity,
            models.GetInstallLatestDeploySecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""get an install deploy

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallLatestDeployRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/deploys/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallLatestDeploySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallLatestDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_deploy(
        self,
        *,
        security: Union[
            models.GetInstallDeploySecurity, models.GetInstallDeploySecurityTypedDict
        ],
        install_id: str,
        deploy_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""get an install deploy

        :param security:
        :param install_id: install ID
        :param deploy_id: deploy ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallDeployRequest(
            install_id=install_id,
            deploy_id=deploy_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/deploys/{deploy_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallDeploySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_deploy_async(
        self,
        *,
        security: Union[
            models.GetInstallDeploySecurity, models.GetInstallDeploySecurityTypedDict
        ],
        install_id: str,
        deploy_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallDeploy:
        r"""get an install deploy

        :param security:
        :param install_id: install ID
        :param deploy_id: deploy ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallDeployRequest(
            install_id=install_id,
            deploy_id=deploy_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/deploys/{deploy_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallDeploySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallDeploy",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallDeploy, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def deprovision_install(
        self,
        *,
        security: Union[
            models.DeprovisionInstallSecurity,
            models.DeprovisionInstallSecurityTypedDict,
        ],
        install_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""deprovision an install

        Deprovision an install sandbox.


        :param security:
        :param install_id: install ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeprovisionInstallRequest(
            install_id=install_id,
            service_deprovision_install_request=models.ServiceDeprovisionInstallRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/deprovision",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeprovisionInstallSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_deprovision_install_request,
                False,
                False,
                "json",
                models.ServiceDeprovisionInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeprovisionInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def deprovision_install_async(
        self,
        *,
        security: Union[
            models.DeprovisionInstallSecurity,
            models.DeprovisionInstallSecurityTypedDict,
        ],
        install_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""deprovision an install

        Deprovision an install sandbox.


        :param security:
        :param install_id: install ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeprovisionInstallRequest(
            install_id=install_id,
            service_deprovision_install_request=models.ServiceDeprovisionInstallRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/deprovision",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeprovisionInstallSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_deprovision_install_request,
                False,
                False,
                "json",
                models.ServiceDeprovisionInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeprovisionInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def deprovision_install_sandbox(
        self,
        *,
        security: Union[
            models.DeprovisionInstallSandboxSecurity,
            models.DeprovisionInstallSandboxSecurityTypedDict,
        ],
        install_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""deprovision an install

        :param security:
        :param install_id: install ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeprovisionInstallSandboxRequest(
            install_id=install_id,
            service_deprovision_install_sandbox_request=models.ServiceDeprovisionInstallSandboxRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/deprovision-sandbox",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeprovisionInstallSandboxSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_deprovision_install_sandbox_request,
                False,
                False,
                "json",
                models.ServiceDeprovisionInstallSandboxRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeprovisionInstallSandbox",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def deprovision_install_sandbox_async(
        self,
        *,
        security: Union[
            models.DeprovisionInstallSandboxSecurity,
            models.DeprovisionInstallSandboxSecurityTypedDict,
        ],
        install_id: str,
        error_behavior: Optional[str] = None,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""deprovision an install

        :param security:
        :param install_id: install ID
        :param error_behavior:
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeprovisionInstallSandboxRequest(
            install_id=install_id,
            service_deprovision_install_sandbox_request=models.ServiceDeprovisionInstallSandboxRequest(
                error_behavior=error_behavior,
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/deprovision-sandbox",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeprovisionInstallSandboxSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_deprovision_install_sandbox_request,
                False,
                False,
                "json",
                models.ServiceDeprovisionInstallSandboxRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeprovisionInstallSandbox",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_events(
        self,
        *,
        security: Union[
            models.GetInstallEventsSecurity, models.GetInstallEventsSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallEvent]:
        r"""get events for an install

        # Get Install Events

        Return an event stream for an install.


        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallEventsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/events",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallEventsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallEvents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallEvent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_events_async(
        self,
        *,
        security: Union[
            models.GetInstallEventsSecurity, models.GetInstallEventsSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallEvent]:
        r"""get events for an install

        # Get Install Events

        Return an event stream for an install.


        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallEventsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/events",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallEventsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallEvents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallEvent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_event(
        self,
        *,
        security: Union[
            models.GetInstallEventSecurity, models.GetInstallEventSecurityTypedDict
        ],
        install_id: str,
        event_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallEvent:
        r"""get an install event

        Get a single install event.


        :param security:
        :param install_id: install ID
        :param event_id: event ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallEventRequest(
            install_id=install_id,
            event_id=event_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/events/{event_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallEventSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallEvent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallEvent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_event_async(
        self,
        *,
        security: Union[
            models.GetInstallEventSecurity, models.GetInstallEventSecurityTypedDict
        ],
        install_id: str,
        event_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallEvent:
        r"""get an install event

        Get a single install event.


        :param security:
        :param install_id: install ID
        :param event_id: event ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallEventRequest(
            install_id=install_id,
            event_id=event_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/events/{event_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallEventSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallEvent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallEvent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def forget_install(
        self,
        *,
        security: Union[
            models.ForgetInstallSecurity, models.ForgetInstallSecurityTypedDict
        ],
        install_id: str,
        service_forget_install_request: Union[
            models.ServiceForgetInstallRequest,
            models.ServiceForgetInstallRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""forget an install

        Forget an install that has been deleted outside of nuon.

        This should only be used in cases where an install was broken in an unordinary way and needs to be manually deleted so the parent resources can be deleted.


        :param security:
        :param install_id: install ID
        :param service_forget_install_request: Input
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ForgetInstallRequest(
            install_id=install_id,
            service_forget_install_request=utils.get_pydantic_model(
                service_forget_install_request, models.ServiceForgetInstallRequest
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/forget",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ForgetInstallSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_forget_install_request,
                False,
                False,
                "json",
                models.ServiceForgetInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ForgetInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def forget_install_async(
        self,
        *,
        security: Union[
            models.ForgetInstallSecurity, models.ForgetInstallSecurityTypedDict
        ],
        install_id: str,
        service_forget_install_request: Union[
            models.ServiceForgetInstallRequest,
            models.ServiceForgetInstallRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""forget an install

        Forget an install that has been deleted outside of nuon.

        This should only be used in cases where an install was broken in an unordinary way and needs to be manually deleted so the parent resources can be deleted.


        :param security:
        :param install_id: install ID
        :param service_forget_install_request: Input
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ForgetInstallRequest(
            install_id=install_id,
            service_forget_install_request=utils.get_pydantic_model(
                service_forget_install_request, models.ServiceForgetInstallRequest
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/forget",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ForgetInstallSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_forget_install_request,
                False,
                False,
                "json",
                models.ServiceForgetInstallRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ForgetInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(http_res, ["400", "404"], "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_inputs(
        self,
        *,
        security: Union[
            models.GetInstallInputsSecurity, models.GetInstallInputsSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallInputs]:
        r"""get an installs inputs

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallInputsRequest(
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/inputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallInputsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallInputs], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_inputs_async(
        self,
        *,
        security: Union[
            models.GetInstallInputsSecurity, models.GetInstallInputsSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallInputs]:
        r"""get an installs inputs

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallInputsRequest(
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/inputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallInputsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallInputs], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def update_install_inputs(
        self,
        *,
        security: Union[
            models.UpdateInstallInputsSecurity,
            models.UpdateInstallInputsSecurityTypedDict,
        ],
        install_id: str,
        inputs: Dict[str, str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallInputs:
        r"""Updates install input config for app

        :param security:
        :param install_id: install ID
        :param inputs:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallInputsRequest(
            install_id=install_id,
            service_update_install_inputs_request=models.ServiceUpdateInstallInputsRequest(
                inputs=inputs,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/installs/{install_id}/inputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateInstallInputsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_install_inputs_request,
                False,
                False,
                "json",
                models.ServiceUpdateInstallInputsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallInputs, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def update_install_inputs_async(
        self,
        *,
        security: Union[
            models.UpdateInstallInputsSecurity,
            models.UpdateInstallInputsSecurityTypedDict,
        ],
        install_id: str,
        inputs: Dict[str, str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallInputs:
        r"""Updates install input config for app

        :param security:
        :param install_id: install ID
        :param inputs:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateInstallInputsRequest(
            install_id=install_id,
            service_update_install_inputs_request=models.ServiceUpdateInstallInputsRequest(
                inputs=inputs,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/installs/{install_id}/inputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateInstallInputsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_install_inputs_request,
                False,
                False,
                "json",
                models.ServiceUpdateInstallInputsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallInputs, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_install_inputs(
        self,
        *,
        security: Union[
            models.CreateInstallInputsSecurity,
            models.CreateInstallInputsSecurityTypedDict,
        ],
        install_id: str,
        inputs: Dict[str, str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallInputs:
        r"""create install inputs

        :param security:
        :param install_id: install ID
        :param inputs:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallInputsRequest(
            install_id=install_id,
            service_create_install_inputs_request=models.ServiceCreateInstallInputsRequest(
                inputs=inputs,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/inputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallInputsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_inputs_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallInputsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallInputs, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_install_inputs_async(
        self,
        *,
        security: Union[
            models.CreateInstallInputsSecurity,
            models.CreateInstallInputsSecurityTypedDict,
        ],
        install_id: str,
        inputs: Dict[str, str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallInputs:
        r"""create install inputs

        :param security:
        :param install_id: install ID
        :param inputs:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateInstallInputsRequest(
            install_id=install_id,
            service_create_install_inputs_request=models.ServiceCreateInstallInputsRequest(
                inputs=inputs,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/inputs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateInstallInputsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_install_inputs_request,
                False,
                False,
                "json",
                models.ServiceCreateInstallInputsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppInstallInputs, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_current_install_inputs(
        self,
        *,
        security: Union[
            models.GetCurrentInstallInputsSecurity,
            models.GetCurrentInstallInputsSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallInputs:
        r"""get an installs current inputs

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCurrentInstallInputsRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/inputs/current",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetCurrentInstallInputsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetCurrentInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallInputs, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_current_install_inputs_async(
        self,
        *,
        security: Union[
            models.GetCurrentInstallInputsSecurity,
            models.GetCurrentInstallInputsSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallInputs:
        r"""get an installs current inputs

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCurrentInstallInputsRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/inputs/current",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetCurrentInstallInputsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetCurrentInstallInputs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallInputs, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def phone_home(
        self,
        *,
        security: Union[models.PhoneHomeSecurity, models.PhoneHomeSecurityTypedDict],
        install_id: str,
        phone_home_id: str,
        request_body: Dict[str, Any],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""phone home for an install

        A public endpoint for phoning home from a runner AWS cloudformation stack upon successfully processing it.


        :param security:
        :param install_id: install ID
        :param phone_home_id: phone home ID
        :param request_body: Input
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PhoneHomeRequest(
            install_id=install_id,
            phone_home_id=phone_home_id,
            request_body=request_body,
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/phone-home/{phone_home_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.PhoneHomeSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body, False, False, "json", Dict[str, Any]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="PhoneHome",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def phone_home_async(
        self,
        *,
        security: Union[models.PhoneHomeSecurity, models.PhoneHomeSecurityTypedDict],
        install_id: str,
        phone_home_id: str,
        request_body: Dict[str, Any],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""phone home for an install

        A public endpoint for phoning home from a runner AWS cloudformation stack upon successfully processing it.


        :param security:
        :param install_id: install ID
        :param phone_home_id: phone home ID
        :param request_body: Input
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PhoneHomeRequest(
            install_id=install_id,
            phone_home_id=phone_home_id,
            request_body=request_body,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/phone-home/{phone_home_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.PhoneHomeSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body, False, False, "json", Dict[str, Any]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="PhoneHome",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_readme(
        self,
        *,
        security: Union[
            models.GetInstallReadmeSecurity, models.GetInstallReadmeSecurityTypedDict
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceReadme:
        r"""get install readme rendered with

        Returns the `app.readme` markdown with the values interpolated from the install
        inputs and component outputs.


        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallReadmeRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/readme",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallReadmeSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallReadme",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, ["200", "206"], "application/json"):
            return unmarshal_json_response(models.ServiceReadme, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_readme_async(
        self,
        *,
        security: Union[
            models.GetInstallReadmeSecurity, models.GetInstallReadmeSecurityTypedDict
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceReadme:
        r"""get install readme rendered with

        Returns the `app.readme` markdown with the values interpolated from the install
        inputs and component outputs.


        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallReadmeRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/readme",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallReadmeSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallReadme",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, ["200", "206"], "application/json"):
            return unmarshal_json_response(models.ServiceReadme, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def reprovision_install(
        self,
        *,
        security: Union[
            models.ReprovisionInstallSecurity,
            models.ReprovisionInstallSecurityTypedDict,
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""reprovision an install

        Reprovision an install sandbox.



        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ReprovisionInstallRequest(
            install_id=install_id,
            service_reprovision_install_request=models.ServiceReprovisionInstallRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/reprovision",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.ReprovisionInstallSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_reprovision_install_request,
                False,
                True,
                "json",
                Optional[models.ServiceReprovisionInstallRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ReprovisionInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def reprovision_install_async(
        self,
        *,
        security: Union[
            models.ReprovisionInstallSecurity,
            models.ReprovisionInstallSecurityTypedDict,
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""reprovision an install

        Reprovision an install sandbox.



        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ReprovisionInstallRequest(
            install_id=install_id,
            service_reprovision_install_request=models.ServiceReprovisionInstallRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/reprovision",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.ReprovisionInstallSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_reprovision_install_request,
                False,
                True,
                "json",
                Optional[models.ServiceReprovisionInstallRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ReprovisionInstall",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def reprovision_install_sandbox(
        self,
        *,
        security: Union[
            models.ReprovisionInstallSandboxSecurity,
            models.ReprovisionInstallSandboxSecurityTypedDict,
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""reprovision an install sandbox

        Reprovision an install sandbox and redeploy all components on top.


        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ReprovisionInstallSandboxRequest(
            install_id=install_id,
            service_reprovision_install_sandbox_request=models.ServiceReprovisionInstallSandboxRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/reprovision-sandbox",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.ReprovisionInstallSandboxSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_reprovision_install_sandbox_request,
                False,
                False,
                "json",
                models.ServiceReprovisionInstallSandboxRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ReprovisionInstallSandbox",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def reprovision_install_sandbox_async(
        self,
        *,
        security: Union[
            models.ReprovisionInstallSandboxSecurity,
            models.ReprovisionInstallSandboxSecurityTypedDict,
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""reprovision an install sandbox

        Reprovision an install sandbox and redeploy all components on top.


        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ReprovisionInstallSandboxRequest(
            install_id=install_id,
            service_reprovision_install_sandbox_request=models.ServiceReprovisionInstallSandboxRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/reprovision-sandbox",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.ReprovisionInstallSandboxSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_reprovision_install_sandbox_request,
                False,
                False,
                "json",
                models.ServiceReprovisionInstallSandboxRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ReprovisionInstallSandbox",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    def retry_workflow(
        self,
        *,
        security: Union[
            models.RetryWorkflowSecurity, models.RetryWorkflowSecurityTypedDict
        ],
        install_id: str,
        operation: Optional[str] = None,
        step_id: Optional[str] = None,
        workflow_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceRetryWorkflowResponse:
        r"""rerun the workflow steps starting from input step id, can be used to retry a failed step

        :param security:
        :param install_id: install ID
        :param operation: Retry indicates whether to retry the current step or not
        :param step_id: StepID is the ID of the step to start the retry from
        :param workflow_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RetryWorkflowRequest(
            install_id=install_id,
            service_retry_workflow_request=models.ServiceRetryWorkflowRequest(
                operation=operation,
                step_id=step_id,
                workflow_id=workflow_id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/retry-workflow",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.RetryWorkflowSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_retry_workflow_request,
                False,
                False,
                "json",
                models.ServiceRetryWorkflowRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RetryWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.ServiceRetryWorkflowResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    async def retry_workflow_async(
        self,
        *,
        security: Union[
            models.RetryWorkflowSecurity, models.RetryWorkflowSecurityTypedDict
        ],
        install_id: str,
        operation: Optional[str] = None,
        step_id: Optional[str] = None,
        workflow_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceRetryWorkflowResponse:
        r"""rerun the workflow steps starting from input step id, can be used to retry a failed step

        :param security:
        :param install_id: install ID
        :param operation: Retry indicates whether to retry the current step or not
        :param step_id: StepID is the ID of the step to start the retry from
        :param workflow_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RetryWorkflowRequest(
            install_id=install_id,
            service_retry_workflow_request=models.ServiceRetryWorkflowRequest(
                operation=operation,
                step_id=step_id,
                workflow_id=workflow_id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/retry-workflow",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.RetryWorkflowSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_retry_workflow_request,
                False,
                False,
                "json",
                models.ServiceRetryWorkflowRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RetryWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.ServiceRetryWorkflowResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_runner_group(
        self,
        *,
        security: Union[
            models.GetInstallRunnerGroupSecurity,
            models.GetInstallRunnerGroupSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppRunnerGroup:
        r"""Get an install's runner group

        Return the runner group, including runners and settings for the provided install.


        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallRunnerGroupRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/runner-group",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallRunnerGroupSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallRunnerGroup",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppRunnerGroup, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_runner_group_async(
        self,
        *,
        security: Union[
            models.GetInstallRunnerGroupSecurity,
            models.GetInstallRunnerGroupSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppRunnerGroup:
        r"""Get an install's runner group

        Return the runner group, including runners and settings for the provided install.


        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallRunnerGroupRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/runner-group",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallRunnerGroupSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallRunnerGroup",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppRunnerGroup, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_sandbox_runs(
        self,
        *,
        security: Union[
            models.GetInstallSandboxRunsSecurity,
            models.GetInstallSandboxRunsSecurityTypedDict,
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallSandboxRun]:
        r"""get an installs sandbox runs

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallSandboxRunsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/sandbox-runs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallSandboxRunsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallSandboxRuns",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallSandboxRun], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_sandbox_runs_async(
        self,
        *,
        security: Union[
            models.GetInstallSandboxRunsSecurity,
            models.GetInstallSandboxRunsSecurityTypedDict,
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppInstallSandboxRun]:
        r"""get an installs sandbox runs

        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallSandboxRunsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/sandbox-runs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallSandboxRunsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallSandboxRuns",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppInstallSandboxRun], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_stack_by_install_id(
        self,
        *,
        security: Union[
            models.GetInstallStackByInstallIDSecurity,
            models.GetInstallStackByInstallIDSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallStack:
        r"""get an install stack by install ID

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStackByInstallIDRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/stack",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallStackByInstallIDSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallStackByInstallID",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallStack, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_stack_by_install_id_async(
        self,
        *,
        security: Union[
            models.GetInstallStackByInstallIDSecurity,
            models.GetInstallStackByInstallIDSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallStack:
        r"""get an install stack by install ID

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStackByInstallIDRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/stack",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallStackByInstallIDSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallStackByInstallID",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallStack, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_stack_runs(
        self,
        *,
        security: Union[
            models.GetInstallStackRunsSecurity,
            models.GetInstallStackRunsSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallStackVersionRun:
        r"""get an install's stack runs

        get install stack runs

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStackRunsRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/stack-runs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallStackRunsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallStackRuns",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallStackVersionRun, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_stack_runs_async(
        self,
        *,
        security: Union[
            models.GetInstallStackRunsSecurity,
            models.GetInstallStackRunsSecurityTypedDict,
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppInstallStackVersionRun:
        r"""get an install's stack runs

        get install stack runs

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStackRunsRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/stack-runs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetInstallStackRunsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallStackRuns",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppInstallStackVersionRun, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_install_state(
        self,
        *,
        security: Union[
            models.GetInstallStateSecurity, models.GetInstallStateSecurityTypedDict
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GithubComPowertoolsdevMonoPkgTypesStateState:
        r"""Get the current state of an install.

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStateRequest(
            install_id=install_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/state",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallStateSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallState",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.GithubComPowertoolsdevMonoPkgTypesStateState, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_install_state_async(
        self,
        *,
        security: Union[
            models.GetInstallStateSecurity, models.GetInstallStateSecurityTypedDict
        ],
        install_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GithubComPowertoolsdevMonoPkgTypesStateState:
        r"""Get the current state of an install.

        :param security:
        :param install_id: install ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetInstallStateRequest(
            install_id=install_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/state",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetInstallStateSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetInstallState",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.GithubComPowertoolsdevMonoPkgTypesStateState, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def sync_secrets(
        self,
        *,
        security: Union[
            models.SyncSecretsSecurity, models.SyncSecretsSecurityTypedDict
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""sync secrets install

        Execute the sync secrets workflow.


        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SyncSecretsRequest(
            install_id=install_id,
            service_sync_secrets_request=models.ServiceSyncSecretsRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/installs/{install_id}/sync-secrets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.SyncSecretsSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_sync_secrets_request,
                False,
                True,
                "json",
                Optional[models.ServiceSyncSecretsRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="SyncSecrets",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def sync_secrets_async(
        self,
        *,
        security: Union[
            models.SyncSecretsSecurity, models.SyncSecretsSecurityTypedDict
        ],
        install_id: str,
        plan_only: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""sync secrets install

        Execute the sync secrets workflow.


        :param security:
        :param install_id: install ID
        :param plan_only:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SyncSecretsRequest(
            install_id=install_id,
            service_sync_secrets_request=models.ServiceSyncSecretsRequest(
                plan_only=plan_only,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/installs/{install_id}/sync-secrets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.SyncSecretsSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_sync_secrets_request,
                False,
                True,
                "json",
                Optional[models.ServiceSyncSecretsRequest],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="SyncSecrets",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_workflows(
        self,
        *,
        security: Union[
            models.GetWorkflowsSecurity, models.GetWorkflowsSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppWorkflow]:
        r"""get workflows

        Return workflows for an install.


        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/installs/{install_id}/workflows",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetWorkflowsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflows",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppWorkflow], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_workflows_async(
        self,
        *,
        security: Union[
            models.GetWorkflowsSecurity, models.GetWorkflowsSecurityTypedDict
        ],
        install_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppWorkflow]:
        r"""get workflows

        Return workflows for an install.


        :param security:
        :param install_id: install ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowsRequest(
            install_id=install_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/installs/{install_id}/workflows",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetWorkflowsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflows",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppWorkflow], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_workflow(
        self,
        *,
        security: Union[
            models.GetWorkflowSecurity, models.GetWorkflowSecurityTypedDict
        ],
        workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""get a workflow

        Return a workflow.


        :param security:
        :param workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowRequest(
            workflow_id=workflow_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/workflows/{workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetWorkflowSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_workflow_async(
        self,
        *,
        security: Union[
            models.GetWorkflowSecurity, models.GetWorkflowSecurityTypedDict
        ],
        workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""get a workflow

        Return a workflow.


        :param security:
        :param workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowRequest(
            workflow_id=workflow_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/workflows/{workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetWorkflowSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def update_workflow(
        self,
        *,
        security: Union[
            models.UpdateWorkflowSecurity, models.UpdateWorkflowSecurityTypedDict
        ],
        workflow_id: str,
        approval_option: models.AppInstallApprovalOption,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""update a workflow

        :param security:
        :param workflow_id: workflow ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateWorkflowRequest(
            workflow_id=workflow_id,
            service_update_workflow_request=models.ServiceUpdateWorkflowRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/workflows/{workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.UpdateWorkflowSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_workflow_request,
                False,
                False,
                "json",
                models.ServiceUpdateWorkflowRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def update_workflow_async(
        self,
        *,
        security: Union[
            models.UpdateWorkflowSecurity, models.UpdateWorkflowSecurityTypedDict
        ],
        workflow_id: str,
        approval_option: models.AppInstallApprovalOption,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflow:
        r"""update a workflow

        :param security:
        :param workflow_id: workflow ID
        :param approval_option:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateWorkflowRequest(
            workflow_id=workflow_id,
            service_update_workflow_request=models.ServiceUpdateWorkflowRequest(
                approval_option=approval_option,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/workflows/{workflow_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.UpdateWorkflowSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_workflow_request,
                False,
                False,
                "json",
                models.ServiceUpdateWorkflowRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflow, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def cancel_workflow(
        self,
        *,
        security: Union[
            models.CancelWorkflowSecurity, models.CancelWorkflowSecurityTypedDict
        ],
        workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""cancel an ongoing workflow

        :param security:
        :param workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CancelWorkflowRequest(
            workflow_id=workflow_id,
        )

        req = self._build_request(
            method="POST",
            path="/v1/workflows/{workflow_id}/cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CancelWorkflowSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CancelWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def cancel_workflow_async(
        self,
        *,
        security: Union[
            models.CancelWorkflowSecurity, models.CancelWorkflowSecurityTypedDict
        ],
        workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""cancel an ongoing workflow

        :param security:
        :param workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CancelWorkflowRequest(
            workflow_id=workflow_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/workflows/{workflow_id}/cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CancelWorkflowSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CancelWorkflow",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def retry_owner_workflow_by_id(
        self,
        *,
        security: Union[
            models.RetryOwnerWorkflowByIDSecurity,
            models.RetryOwnerWorkflowByIDSecurityTypedDict,
        ],
        workflow_id: str,
        operation: Optional[str] = None,
        step_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceRetryWorkflowByIDResponse:
        r"""rerun the workflow steps starting from input step id, can be used to retry a failed step

        :param security:
        :param workflow_id: workflow ID
        :param operation: Retry indicates whether to retry the current step or not
        :param step_id: StepID is the ID of the step to start the retry from
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RetryOwnerWorkflowByIDRequest(
            workflow_id=workflow_id,
            service_retry_workflow_by_id_request=models.ServiceRetryWorkflowByIDRequest(
                operation=operation,
                step_id=step_id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/workflows/{workflow_id}/retry",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.RetryOwnerWorkflowByIDSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_retry_workflow_by_id_request,
                False,
                False,
                "json",
                models.ServiceRetryWorkflowByIDRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RetryOwnerWorkflowByID",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.ServiceRetryWorkflowByIDResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def retry_owner_workflow_by_id_async(
        self,
        *,
        security: Union[
            models.RetryOwnerWorkflowByIDSecurity,
            models.RetryOwnerWorkflowByIDSecurityTypedDict,
        ],
        workflow_id: str,
        operation: Optional[str] = None,
        step_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceRetryWorkflowByIDResponse:
        r"""rerun the workflow steps starting from input step id, can be used to retry a failed step

        :param security:
        :param workflow_id: workflow ID
        :param operation: Retry indicates whether to retry the current step or not
        :param step_id: StepID is the ID of the step to start the retry from
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RetryOwnerWorkflowByIDRequest(
            workflow_id=workflow_id,
            service_retry_workflow_by_id_request=models.ServiceRetryWorkflowByIDRequest(
                operation=operation,
                step_id=step_id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/workflows/{workflow_id}/retry",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.RetryOwnerWorkflowByIDSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_retry_workflow_by_id_request,
                False,
                False,
                "json",
                models.ServiceRetryWorkflowByIDRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RetryOwnerWorkflowByID",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.ServiceRetryWorkflowByIDResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_workflow_steps(
        self,
        *,
        security: Union[
            models.GetWorkflowStepsSecurity, models.GetWorkflowStepsSecurityTypedDict
        ],
        workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppWorkflowStep]:
        r"""get a workflow step

        Return all steps for a workflow.


        :param security:
        :param workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepsRequest(
            workflow_id=workflow_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetWorkflowStepsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowSteps",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppWorkflowStep], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_workflow_steps_async(
        self,
        *,
        security: Union[
            models.GetWorkflowStepsSecurity, models.GetWorkflowStepsSecurityTypedDict
        ],
        workflow_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppWorkflowStep]:
        r"""get a workflow step

        Return all steps for a workflow.


        :param security:
        :param workflow_id: workflow ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepsRequest(
            workflow_id=workflow_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetWorkflowStepsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowSteps",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppWorkflowStep], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_workflow_step(
        self,
        *,
        security: Union[
            models.GetWorkflowStepSecurity, models.GetWorkflowStepSecurityTypedDict
        ],
        workflow_id: str,
        workflow_step_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStep:
        r"""get a workflow step

        Return a single workflow step.


        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetWorkflowStepSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowStep",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStep, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_workflow_step_async(
        self,
        *,
        security: Union[
            models.GetWorkflowStepSecurity, models.GetWorkflowStepSecurityTypedDict
        ],
        workflow_id: str,
        workflow_step_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStep:
        r"""get a workflow step

        Return a single workflow step.


        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetWorkflowStepSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowStep",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStep, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_workflow_step_approval(
        self,
        *,
        security: Union[
            models.GetWorkflowStepApprovalSecurity,
            models.GetWorkflowStepApprovalSecurityTypedDict,
        ],
        workflow_id: str,
        workflow_step_id: str,
        approval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApproval:
        r"""get an workflow step approval

        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param approval_id: approval id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepApprovalRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
            approval_id=approval_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}/approvals/{approval_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetWorkflowStepApprovalSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowStepApproval",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStepApproval, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_workflow_step_approval_async(
        self,
        *,
        security: Union[
            models.GetWorkflowStepApprovalSecurity,
            models.GetWorkflowStepApprovalSecurityTypedDict,
        ],
        workflow_id: str,
        workflow_step_id: str,
        approval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApproval:
        r"""get an workflow step approval

        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param approval_id: approval id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepApprovalRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
            approval_id=approval_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}/approvals/{approval_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetWorkflowStepApprovalSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowStepApproval",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppWorkflowStepApproval, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_workflow_step_approval_contents(
        self,
        *,
        security: Union[
            models.GetWorkflowStepApprovalContentsSecurity,
            models.GetWorkflowStepApprovalContentsSecurityTypedDict,
        ],
        workflow_id: str,
        workflow_step_id: str,
        approval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[int]:
        r"""get a workflow step approval contents

        Return the contents of a json plan for an approval (compressed).


        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param approval_id: approval id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepApprovalContentsRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
            approval_id=approval_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}/approvals/{approval_id}/contents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetWorkflowStepApprovalContentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowStepApprovalContents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[int], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_workflow_step_approval_contents_async(
        self,
        *,
        security: Union[
            models.GetWorkflowStepApprovalContentsSecurity,
            models.GetWorkflowStepApprovalContentsSecurityTypedDict,
        ],
        workflow_id: str,
        workflow_step_id: str,
        approval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[int]:
        r"""get a workflow step approval contents

        Return the contents of a json plan for an approval (compressed).


        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param approval_id: approval id
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetWorkflowStepApprovalContentsRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
            approval_id=approval_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}/approvals/{approval_id}/contents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetWorkflowStepApprovalContentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetWorkflowStepApprovalContents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[int], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_workflow_step_approval_response(
        self,
        *,
        security: Union[
            models.CreateWorkflowStepApprovalResponseSecurity,
            models.CreateWorkflowStepApprovalResponseSecurityTypedDict,
        ],
        workflow_id: str,
        workflow_step_id: str,
        approval_id: str,
        note: Optional[str] = None,
        response_type: Optional[models.AppWorkflowStepResponseType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApprovalResponse:
        r"""deploy a build to an install

        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param approval_id: approval id
        :param note:
        :param response_type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateWorkflowStepApprovalResponseRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
            approval_id=approval_id,
            service_create_workflow_step_approval_response_request=models.ServiceCreateWorkflowStepApprovalResponseRequest(
                note=note,
                response_type=response_type,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}/approvals/{approval_id}/response",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateWorkflowStepApprovalResponseSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_workflow_step_approval_response_request,
                False,
                False,
                "json",
                models.ServiceCreateWorkflowStepApprovalResponseRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateWorkflowStepApprovalResponse",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppWorkflowStepApprovalResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_workflow_step_approval_response_async(
        self,
        *,
        security: Union[
            models.CreateWorkflowStepApprovalResponseSecurity,
            models.CreateWorkflowStepApprovalResponseSecurityTypedDict,
        ],
        workflow_id: str,
        workflow_step_id: str,
        approval_id: str,
        note: Optional[str] = None,
        response_type: Optional[models.AppWorkflowStepResponseType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppWorkflowStepApprovalResponse:
        r"""deploy a build to an install

        :param security:
        :param workflow_id: workflow id
        :param workflow_step_id: step id
        :param approval_id: approval id
        :param note:
        :param response_type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateWorkflowStepApprovalResponseRequest(
            workflow_id=workflow_id,
            workflow_step_id=workflow_step_id,
            approval_id=approval_id,
            service_create_workflow_step_approval_response_request=models.ServiceCreateWorkflowStepApprovalResponseRequest(
                note=note,
                response_type=response_type,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/workflows/{workflow_id}/steps/{workflow_step_id}/approvals/{approval_id}/response",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateWorkflowStepApprovalResponseSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_workflow_step_approval_response_request,
                False,
                False,
                "json",
                models.ServiceCreateWorkflowStepApprovalResponseRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateWorkflowStepApprovalResponse",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppWorkflowStepApprovalResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)
