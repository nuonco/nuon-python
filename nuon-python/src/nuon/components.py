"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from nuon import errors, models, utils
from nuon._hooks import HookContext
from nuon.types import OptionalNullable, UNSET
from nuon.utils import get_security_from_env
from nuon.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional, Union


class Components(BaseSDK):
    r"""components"""

    def get_app_component(
        self,
        *,
        security: Union[
            models.GetAppComponentSecurity, models.GetAppComponentSecurityTypedDict
        ],
        app_id: str,
        component_name_or_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""get a components for a specific app

        Return an app component by id or name.


        :param security:
        :param app_id: app ID
        :param component_name_or_id: name or ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAppComponentRequest(
            app_id=app_id,
            component_name_or_id=component_name_or_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/apps/{app_id}/component/{component_name_or_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAppComponentSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAppComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_app_component_async(
        self,
        *,
        security: Union[
            models.GetAppComponentSecurity, models.GetAppComponentSecurityTypedDict
        ],
        app_id: str,
        component_name_or_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""get a components for a specific app

        Return an app component by id or name.


        :param security:
        :param app_id: app ID
        :param component_name_or_id: name or ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAppComponentRequest(
            app_id=app_id,
            component_name_or_id=component_name_or_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/apps/{app_id}/component/{component_name_or_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAppComponentSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAppComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_app_components(
        self,
        *,
        security: Union[
            models.GetAppComponentsSecurity, models.GetAppComponentsSecurityTypedDict
        ],
        app_id: str,
        q: Optional[str] = None,
        types: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponent]:
        r"""get all components for an app

        :param security:
        :param app_id: app ID
        :param q: search query to filter components by name
        :param types: comma-separated list of component types to filter by (e.g., terraform_module, helm_chart)
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAppComponentsRequest(
            app_id=app_id,
            q=q,
            types=types,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/apps/{app_id}/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetAppComponentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAppComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_app_components_async(
        self,
        *,
        security: Union[
            models.GetAppComponentsSecurity, models.GetAppComponentsSecurityTypedDict
        ],
        app_id: str,
        q: Optional[str] = None,
        types: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponent]:
        r"""get all components for an app

        :param security:
        :param app_id: app ID
        :param q: search query to filter components by name
        :param types: comma-separated list of component types to filter by (e.g., terraform_module, helm_chart)
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAppComponentsRequest(
            app_id=app_id,
            q=q,
            types=types,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/apps/{app_id}/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetAppComponentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAppComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_component(
        self,
        *,
        security: Union[
            models.CreateComponentSecurity, models.CreateComponentSecurityTypedDict
        ],
        app_id: str,
        name: str,
        dependencies: Optional[List[str]] = None,
        var_name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""create a component

        :param security:
        :param app_id: app ID
        :param name:
        :param dependencies:
        :param var_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateComponentRequest(
            app_id=app_id,
            service_create_component_request=models.ServiceCreateComponentRequest(
                dependencies=dependencies,
                name=name,
                var_name=var_name,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/apps/{app_id}/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateComponentSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_component_request,
                False,
                False,
                "json",
                models.ServiceCreateComponentRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_component_async(
        self,
        *,
        security: Union[
            models.CreateComponentSecurity, models.CreateComponentSecurityTypedDict
        ],
        app_id: str,
        name: str,
        dependencies: Optional[List[str]] = None,
        var_name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""create a component

        :param security:
        :param app_id: app ID
        :param name:
        :param dependencies:
        :param var_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateComponentRequest(
            app_id=app_id,
            service_create_component_request=models.ServiceCreateComponentRequest(
                dependencies=dependencies,
                name=name,
                var_name=var_name,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/apps/{app_id}/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateComponentSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_component_request,
                False,
                False,
                "json",
                models.ServiceCreateComponentRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_builds(
        self,
        *,
        security: Union[
            models.GetComponentBuildsSecurity,
            models.GetComponentBuildsSecurityTypedDict,
        ],
        component_id: Optional[str] = None,
        app_id: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponentBuild]:
        r"""get builds for components

        :param security:
        :param component_id: component id to filter by
        :param app_id: app id to filter by
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentBuildsRequest(
            component_id=component_id,
            app_id=app_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/builds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentBuildsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentBuilds",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponentBuild], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_builds_async(
        self,
        *,
        security: Union[
            models.GetComponentBuildsSecurity,
            models.GetComponentBuildsSecurityTypedDict,
        ],
        component_id: Optional[str] = None,
        app_id: Optional[str] = None,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponentBuild]:
        r"""get builds for components

        :param security:
        :param component_id: component id to filter by
        :param app_id: app id to filter by
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentBuildsRequest(
            component_id=component_id,
            app_id=app_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/builds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentBuildsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentBuilds",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponentBuild], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_org_components(
        self,
        *,
        security: Union[
            models.GetOrgComponentsSecurity, models.GetOrgComponentsSecurityTypedDict
        ],
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponent]:
        r"""get all components for an org

        :param security:
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetOrgComponentsRequest(
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetOrgComponentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetOrgComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_org_components_async(
        self,
        *,
        security: Union[
            models.GetOrgComponentsSecurity, models.GetOrgComponentsSecurityTypedDict
        ],
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponent]:
        r"""get all components for an org

        :param security:
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetOrgComponentsRequest(
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetOrgComponentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetOrgComponents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_build(
        self,
        *,
        security: Union[models.GetBuildSecurity, models.GetBuildSecurityTypedDict],
        build_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""get a build

        Returns builds for one or all components in an app.


        :param security:
        :param build_id: build ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBuildRequest(
            build_id=build_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/builds/{build_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetBuildSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_build_async(
        self,
        *,
        security: Union[models.GetBuildSecurity, models.GetBuildSecurityTypedDict],
        build_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""get a build

        Returns builds for one or all components in an app.


        :param security:
        :param build_id: build ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBuildRequest(
            build_id=build_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/builds/{build_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetBuildSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def delete_component(
        self,
        *,
        security: Union[
            models.DeleteComponentSecurity, models.DeleteComponentSecurityTypedDict
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""delete a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteComponentRequest(
            component_id=component_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/v1/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.DeleteComponentSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def delete_component_async(
        self,
        *,
        security: Union[
            models.DeleteComponentSecurity, models.DeleteComponentSecurityTypedDict
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> bool:
        r"""delete a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteComponentRequest(
            component_id=component_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v1/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.DeleteComponentSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(bool, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component(
        self,
        *,
        security: Union[
            models.GetComponentSecurity, models.GetComponentSecurityTypedDict
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""get a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentRequest(
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetComponentSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_async(
        self,
        *,
        security: Union[
            models.GetComponentSecurity, models.GetComponentSecurityTypedDict
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""get a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentRequest(
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetComponentSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def update_component(
        self,
        *,
        security: Union[
            models.UpdateComponentSecurity, models.UpdateComponentSecurityTypedDict
        ],
        component_id: str,
        name: str,
        dependencies: Optional[List[str]] = None,
        var_name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""update a component

        :param security:
        :param component_id: component ID
        :param name:
        :param dependencies:
        :param var_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComponentRequest(
            component_id=component_id,
            service_update_component_request=models.ServiceUpdateComponentRequest(
                dependencies=dependencies,
                name=name,
                var_name=var_name,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.UpdateComponentSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_component_request,
                False,
                False,
                "json",
                models.ServiceUpdateComponentRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def update_component_async(
        self,
        *,
        security: Union[
            models.UpdateComponentSecurity, models.UpdateComponentSecurityTypedDict
        ],
        component_id: str,
        name: str,
        dependencies: Optional[List[str]] = None,
        var_name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponent:
        r"""update a component

        :param security:
        :param component_id: component ID
        :param name:
        :param dependencies:
        :param var_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComponentRequest(
            component_id=component_id,
            service_update_component_request=models.ServiceUpdateComponentRequest(
                dependencies=dependencies,
                name=name,
                var_name=var_name,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/components/{component_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.UpdateComponentSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_update_component_request,
                False,
                False,
                "json",
                models.ServiceUpdateComponentRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateComponent",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponent, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_component_build(
        self,
        *,
        security: Union[
            models.CreateComponentBuildSecurity,
            models.CreateComponentBuildSecurityTypedDict,
        ],
        component_id: str,
        git_ref: Optional[str] = None,
        use_latest: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""create component build

        :param security:
        :param component_id: component ID
        :param git_ref:
        :param use_latest:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateComponentBuildRequest(
            component_id=component_id,
            service_create_component_build_request=models.ServiceCreateComponentBuildRequest(
                git_ref=git_ref,
                use_latest=use_latest,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/builds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateComponentBuildSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_component_build_request,
                False,
                False,
                "json",
                models.ServiceCreateComponentBuildRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateComponentBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_component_build_async(
        self,
        *,
        security: Union[
            models.CreateComponentBuildSecurity,
            models.CreateComponentBuildSecurityTypedDict,
        ],
        component_id: str,
        git_ref: Optional[str] = None,
        use_latest: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""create component build

        :param security:
        :param component_id: component ID
        :param git_ref:
        :param use_latest:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateComponentBuildRequest(
            component_id=component_id,
            service_create_component_build_request=models.ServiceCreateComponentBuildRequest(
                git_ref=git_ref,
                use_latest=use_latest,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/builds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateComponentBuildSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_component_build_request,
                False,
                False,
                "json",
                models.ServiceCreateComponentBuildRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateComponentBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_latest_build(
        self,
        *,
        security: Union[
            models.GetComponentLatestBuildSecurity,
            models.GetComponentLatestBuildSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""get latest build for a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentLatestBuildRequest(
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/builds/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentLatestBuildSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentLatestBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_latest_build_async(
        self,
        *,
        security: Union[
            models.GetComponentLatestBuildSecurity,
            models.GetComponentLatestBuildSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""get latest build for a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentLatestBuildRequest(
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/builds/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentLatestBuildSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentLatestBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_build(
        self,
        *,
        security: Union[
            models.GetComponentBuildSecurity, models.GetComponentBuildSecurityTypedDict
        ],
        component_id: str,
        build_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""get a build for a component

        Returns builds for one or all components in an app.


        :param security:
        :param component_id: component ID
        :param build_id: build ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentBuildRequest(
            component_id=component_id,
            build_id=build_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/builds/{build_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentBuildSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_build_async(
        self,
        *,
        security: Union[
            models.GetComponentBuildSecurity, models.GetComponentBuildSecurityTypedDict
        ],
        component_id: str,
        build_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentBuild:
        r"""get a build for a component

        Returns builds for one or all components in an app.


        :param security:
        :param component_id: component ID
        :param build_id: build ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentBuildRequest(
            component_id=component_id,
            build_id=build_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/builds/{build_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentBuildSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentBuild",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AppComponentBuild, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_configs(
        self,
        *,
        security: Union[
            models.GetComponentConfigsSecurity,
            models.GetComponentConfigsSecurityTypedDict,
        ],
        component_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponentConfigConnection]:
        r"""get all configs for a component

        :param security:
        :param component_id: component ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentConfigsRequest(
            component_id=component_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/configs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentConfigsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentConfigs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                List[models.AppComponentConfigConnection], http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_configs_async(
        self,
        *,
        security: Union[
            models.GetComponentConfigsSecurity,
            models.GetComponentConfigsSecurityTypedDict,
        ],
        component_id: str,
        offset: Optional[int] = 0,
        limit: Optional[int] = 10,
        page: Optional[int] = 0,
        x_nuon_pagination_enabled: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponentConfigConnection]:
        r"""get all configs for a component

        :param security:
        :param component_id: component ID
        :param offset: offset of results to return
        :param limit: limit of results to return
        :param page: page number of results to return
        :param x_nuon_pagination_enabled: Enable pagination
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentConfigsRequest(
            component_id=component_id,
            offset=offset,
            limit=limit,
            page=page,
            x_nuon_pagination_enabled=x_nuon_pagination_enabled,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/configs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentConfigsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentConfigs",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                List[models.AppComponentConfigConnection], http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_docker_build_component_config(
        self,
        *,
        security: Union[
            models.CreateDockerBuildComponentConfigSecurity,
            models.CreateDockerBuildComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        dockerfile: str,
        app_config_id: Optional[str] = None,
        build_args: Optional[List[str]] = None,
        checksum: Optional[str] = None,
        connected_github_vcs_config: Optional[
            Union[
                models.ServiceConnectedGithubVCSConfigRequest,
                models.ServiceConnectedGithubVCSConfigRequestTypedDict,
            ]
        ] = None,
        dependencies: Optional[List[str]] = None,
        env_vars: Optional[Dict[str, str]] = None,
        public_git_vcs_config: Optional[
            Union[
                models.ServicePublicGitVCSConfigRequest,
                models.ServicePublicGitVCSConfigRequestTypedDict,
            ]
        ] = None,
        references: Optional[List[str]] = None,
        target: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppDockerBuildComponentConfig:
        r"""create a docker build component config

        :param security:
        :param component_id: component ID
        :param dockerfile:
        :param app_config_id:
        :param build_args:
        :param checksum:
        :param connected_github_vcs_config:
        :param dependencies:
        :param env_vars:
        :param public_git_vcs_config:
        :param references:
        :param target:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateDockerBuildComponentConfigRequest(
            component_id=component_id,
            service_create_docker_build_component_config_request=models.ServiceCreateDockerBuildComponentConfigRequest(
                app_config_id=app_config_id,
                build_args=build_args,
                checksum=checksum,
                connected_github_vcs_config=utils.get_pydantic_model(
                    connected_github_vcs_config,
                    Optional[models.ServiceConnectedGithubVCSConfigRequest],
                ),
                dependencies=dependencies,
                dockerfile=dockerfile,
                env_vars=env_vars,
                public_git_vcs_config=utils.get_pydantic_model(
                    public_git_vcs_config,
                    Optional[models.ServicePublicGitVCSConfigRequest],
                ),
                references=references,
                target=target,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/configs/docker-build",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateDockerBuildComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_docker_build_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateDockerBuildComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateDockerBuildComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppDockerBuildComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_docker_build_component_config_async(
        self,
        *,
        security: Union[
            models.CreateDockerBuildComponentConfigSecurity,
            models.CreateDockerBuildComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        dockerfile: str,
        app_config_id: Optional[str] = None,
        build_args: Optional[List[str]] = None,
        checksum: Optional[str] = None,
        connected_github_vcs_config: Optional[
            Union[
                models.ServiceConnectedGithubVCSConfigRequest,
                models.ServiceConnectedGithubVCSConfigRequestTypedDict,
            ]
        ] = None,
        dependencies: Optional[List[str]] = None,
        env_vars: Optional[Dict[str, str]] = None,
        public_git_vcs_config: Optional[
            Union[
                models.ServicePublicGitVCSConfigRequest,
                models.ServicePublicGitVCSConfigRequestTypedDict,
            ]
        ] = None,
        references: Optional[List[str]] = None,
        target: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppDockerBuildComponentConfig:
        r"""create a docker build component config

        :param security:
        :param component_id: component ID
        :param dockerfile:
        :param app_config_id:
        :param build_args:
        :param checksum:
        :param connected_github_vcs_config:
        :param dependencies:
        :param env_vars:
        :param public_git_vcs_config:
        :param references:
        :param target:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateDockerBuildComponentConfigRequest(
            component_id=component_id,
            service_create_docker_build_component_config_request=models.ServiceCreateDockerBuildComponentConfigRequest(
                app_config_id=app_config_id,
                build_args=build_args,
                checksum=checksum,
                connected_github_vcs_config=utils.get_pydantic_model(
                    connected_github_vcs_config,
                    Optional[models.ServiceConnectedGithubVCSConfigRequest],
                ),
                dependencies=dependencies,
                dockerfile=dockerfile,
                env_vars=env_vars,
                public_git_vcs_config=utils.get_pydantic_model(
                    public_git_vcs_config,
                    Optional[models.ServicePublicGitVCSConfigRequest],
                ),
                references=references,
                target=target,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/configs/docker-build",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateDockerBuildComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_docker_build_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateDockerBuildComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateDockerBuildComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppDockerBuildComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_external_image_component_config(
        self,
        *,
        security: Union[
            models.CreateExternalImageComponentConfigSecurity,
            models.CreateExternalImageComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        image_url: str,
        tag: str,
        app_config_id: Optional[str] = None,
        aws_ecr_image_config: Optional[
            Union[
                models.ServiceAwsECRImageConfigRequest,
                models.ServiceAwsECRImageConfigRequestTypedDict,
            ]
        ] = None,
        checksum: Optional[str] = None,
        dependencies: Optional[List[str]] = None,
        references: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppExternalImageComponentConfig:
        r"""create an external image component config

        :param security:
        :param component_id: component ID
        :param image_url:
        :param tag:
        :param app_config_id:
        :param aws_ecr_image_config:
        :param checksum:
        :param dependencies:
        :param references:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateExternalImageComponentConfigRequest(
            component_id=component_id,
            service_create_external_image_component_config_request=models.ServiceCreateExternalImageComponentConfigRequest(
                app_config_id=app_config_id,
                aws_ecr_image_config=utils.get_pydantic_model(
                    aws_ecr_image_config,
                    Optional[models.ServiceAwsECRImageConfigRequest],
                ),
                checksum=checksum,
                dependencies=dependencies,
                image_url=image_url,
                references=references,
                tag=tag,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/configs/external-image",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateExternalImageComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_external_image_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateExternalImageComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateExternalImageComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppExternalImageComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_external_image_component_config_async(
        self,
        *,
        security: Union[
            models.CreateExternalImageComponentConfigSecurity,
            models.CreateExternalImageComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        image_url: str,
        tag: str,
        app_config_id: Optional[str] = None,
        aws_ecr_image_config: Optional[
            Union[
                models.ServiceAwsECRImageConfigRequest,
                models.ServiceAwsECRImageConfigRequestTypedDict,
            ]
        ] = None,
        checksum: Optional[str] = None,
        dependencies: Optional[List[str]] = None,
        references: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppExternalImageComponentConfig:
        r"""create an external image component config

        :param security:
        :param component_id: component ID
        :param image_url:
        :param tag:
        :param app_config_id:
        :param aws_ecr_image_config:
        :param checksum:
        :param dependencies:
        :param references:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateExternalImageComponentConfigRequest(
            component_id=component_id,
            service_create_external_image_component_config_request=models.ServiceCreateExternalImageComponentConfigRequest(
                app_config_id=app_config_id,
                aws_ecr_image_config=utils.get_pydantic_model(
                    aws_ecr_image_config,
                    Optional[models.ServiceAwsECRImageConfigRequest],
                ),
                checksum=checksum,
                dependencies=dependencies,
                image_url=image_url,
                references=references,
                tag=tag,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/configs/external-image",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateExternalImageComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_external_image_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateExternalImageComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateExternalImageComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppExternalImageComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_helm_component_config(
        self,
        *,
        security: Union[
            models.CreateHelmComponentConfigSecurity,
            models.CreateHelmComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        chart_name: str,
        values: Dict[str, str],
        app_config_id: Optional[str] = None,
        checksum: Optional[str] = None,
        connected_github_vcs_config: Optional[
            Union[
                models.ServiceConnectedGithubVCSConfigRequest,
                models.ServiceConnectedGithubVCSConfigRequestTypedDict,
            ]
        ] = None,
        dependencies: Optional[List[str]] = None,
        namespace: Optional[str] = None,
        public_git_vcs_config: Optional[
            Union[
                models.ServicePublicGitVCSConfigRequest,
                models.ServicePublicGitVCSConfigRequestTypedDict,
            ]
        ] = None,
        references: Optional[List[str]] = None,
        storage_driver: Optional[str] = None,
        take_ownership: Optional[bool] = None,
        values_files: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppHelmComponentConfig:
        r"""create a helm component config

        Create a helm component config.


        :param security:
        :param component_id: component ID
        :param chart_name:
        :param values:
        :param app_config_id:
        :param checksum:
        :param connected_github_vcs_config:
        :param dependencies:
        :param namespace:
        :param public_git_vcs_config:
        :param references:
        :param storage_driver:
        :param take_ownership:
        :param values_files:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateHelmComponentConfigRequest(
            component_id=component_id,
            service_create_helm_component_config_request=models.ServiceCreateHelmComponentConfigRequest(
                app_config_id=app_config_id,
                chart_name=chart_name,
                checksum=checksum,
                connected_github_vcs_config=utils.get_pydantic_model(
                    connected_github_vcs_config,
                    Optional[models.ServiceConnectedGithubVCSConfigRequest],
                ),
                dependencies=dependencies,
                namespace=namespace,
                public_git_vcs_config=utils.get_pydantic_model(
                    public_git_vcs_config,
                    Optional[models.ServicePublicGitVCSConfigRequest],
                ),
                references=references,
                storage_driver=storage_driver,
                take_ownership=take_ownership,
                values=values,
                values_files=values_files,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/configs/helm",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateHelmComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_helm_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateHelmComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateHelmComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppHelmComponentConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_helm_component_config_async(
        self,
        *,
        security: Union[
            models.CreateHelmComponentConfigSecurity,
            models.CreateHelmComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        chart_name: str,
        values: Dict[str, str],
        app_config_id: Optional[str] = None,
        checksum: Optional[str] = None,
        connected_github_vcs_config: Optional[
            Union[
                models.ServiceConnectedGithubVCSConfigRequest,
                models.ServiceConnectedGithubVCSConfigRequestTypedDict,
            ]
        ] = None,
        dependencies: Optional[List[str]] = None,
        namespace: Optional[str] = None,
        public_git_vcs_config: Optional[
            Union[
                models.ServicePublicGitVCSConfigRequest,
                models.ServicePublicGitVCSConfigRequestTypedDict,
            ]
        ] = None,
        references: Optional[List[str]] = None,
        storage_driver: Optional[str] = None,
        take_ownership: Optional[bool] = None,
        values_files: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppHelmComponentConfig:
        r"""create a helm component config

        Create a helm component config.


        :param security:
        :param component_id: component ID
        :param chart_name:
        :param values:
        :param app_config_id:
        :param checksum:
        :param connected_github_vcs_config:
        :param dependencies:
        :param namespace:
        :param public_git_vcs_config:
        :param references:
        :param storage_driver:
        :param take_ownership:
        :param values_files:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateHelmComponentConfigRequest(
            component_id=component_id,
            service_create_helm_component_config_request=models.ServiceCreateHelmComponentConfigRequest(
                app_config_id=app_config_id,
                chart_name=chart_name,
                checksum=checksum,
                connected_github_vcs_config=utils.get_pydantic_model(
                    connected_github_vcs_config,
                    Optional[models.ServiceConnectedGithubVCSConfigRequest],
                ),
                dependencies=dependencies,
                namespace=namespace,
                public_git_vcs_config=utils.get_pydantic_model(
                    public_git_vcs_config,
                    Optional[models.ServicePublicGitVCSConfigRequest],
                ),
                references=references,
                storage_driver=storage_driver,
                take_ownership=take_ownership,
                values=values,
                values_files=values_files,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/configs/helm",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateHelmComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_helm_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateHelmComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateHelmComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppHelmComponentConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_job_component_config(
        self,
        *,
        security: Union[
            models.CreateJobComponentConfigSecurity,
            models.CreateJobComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        image_url: str,
        tag: str,
        app_config_id: Optional[str] = None,
        args: Optional[List[str]] = None,
        checksum: Optional[str] = None,
        cmd: Optional[List[str]] = None,
        env_vars: Optional[Dict[str, str]] = None,
        references: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppJobComponentConfig:
        r"""create a job component config

        :param security:
        :param component_id: component ID
        :param image_url:
        :param tag:
        :param app_config_id:
        :param args:
        :param checksum:
        :param cmd:
        :param env_vars:
        :param references:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateJobComponentConfigRequest(
            component_id=component_id,
            service_create_job_component_config_request=models.ServiceCreateJobComponentConfigRequest(
                app_config_id=app_config_id,
                args=args,
                checksum=checksum,
                cmd=cmd,
                env_vars=env_vars,
                image_url=image_url,
                references=references,
                tag=tag,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/configs/job",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateJobComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_job_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateJobComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateJobComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppJobComponentConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_job_component_config_async(
        self,
        *,
        security: Union[
            models.CreateJobComponentConfigSecurity,
            models.CreateJobComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        image_url: str,
        tag: str,
        app_config_id: Optional[str] = None,
        args: Optional[List[str]] = None,
        checksum: Optional[str] = None,
        cmd: Optional[List[str]] = None,
        env_vars: Optional[Dict[str, str]] = None,
        references: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppJobComponentConfig:
        r"""create a job component config

        :param security:
        :param component_id: component ID
        :param image_url:
        :param tag:
        :param app_config_id:
        :param args:
        :param checksum:
        :param cmd:
        :param env_vars:
        :param references:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateJobComponentConfigRequest(
            component_id=component_id,
            service_create_job_component_config_request=models.ServiceCreateJobComponentConfigRequest(
                app_config_id=app_config_id,
                args=args,
                checksum=checksum,
                cmd=cmd,
                env_vars=env_vars,
                image_url=image_url,
                references=references,
                tag=tag,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/configs/job",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateJobComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_job_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateJobComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateJobComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.AppJobComponentConfig, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_kubernetes_manifest_component_config(
        self,
        *,
        security: Union[
            models.CreateKubernetesManifestComponentConfigSecurity,
            models.CreateKubernetesManifestComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        app_config_id: Optional[str] = None,
        checksum: Optional[str] = None,
        dependencies: Optional[List[str]] = None,
        manifest: Optional[str] = None,
        namespace: Optional[str] = None,
        references: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppKubernetesManifestComponentConfig:
        r"""create a kubernetes manifest component config

        :param security:
        :param component_id: component ID
        :param app_config_id:
        :param checksum:
        :param dependencies:
        :param manifest:
        :param namespace:
        :param references:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateKubernetesManifestComponentConfigRequest(
            component_id=component_id,
            service_create_kubernetes_manifest_component_config_request=models.ServiceCreateKubernetesManifestComponentConfigRequest(
                app_config_id=app_config_id,
                checksum=checksum,
                dependencies=dependencies,
                manifest=manifest,
                namespace=namespace,
                references=references,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/configs/kubernetes-manifest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateKubernetesManifestComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_kubernetes_manifest_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateKubernetesManifestComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateKubernetesManifestComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppKubernetesManifestComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_kubernetes_manifest_component_config_async(
        self,
        *,
        security: Union[
            models.CreateKubernetesManifestComponentConfigSecurity,
            models.CreateKubernetesManifestComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        app_config_id: Optional[str] = None,
        checksum: Optional[str] = None,
        dependencies: Optional[List[str]] = None,
        manifest: Optional[str] = None,
        namespace: Optional[str] = None,
        references: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppKubernetesManifestComponentConfig:
        r"""create a kubernetes manifest component config

        :param security:
        :param component_id: component ID
        :param app_config_id:
        :param checksum:
        :param dependencies:
        :param manifest:
        :param namespace:
        :param references:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateKubernetesManifestComponentConfigRequest(
            component_id=component_id,
            service_create_kubernetes_manifest_component_config_request=models.ServiceCreateKubernetesManifestComponentConfigRequest(
                app_config_id=app_config_id,
                checksum=checksum,
                dependencies=dependencies,
                manifest=manifest,
                namespace=namespace,
                references=references,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/configs/kubernetes-manifest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateKubernetesManifestComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_kubernetes_manifest_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateKubernetesManifestComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateKubernetesManifestComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppKubernetesManifestComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_latest_config(
        self,
        *,
        security: Union[
            models.GetComponentLatestConfigSecurity,
            models.GetComponentLatestConfigSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentConfigConnection:
        r"""get latest config for a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentLatestConfigRequest(
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/configs/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentLatestConfigSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentLatestConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.AppComponentConfigConnection, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_latest_config_async(
        self,
        *,
        security: Union[
            models.GetComponentLatestConfigSecurity,
            models.GetComponentLatestConfigSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentConfigConnection:
        r"""get latest config for a component

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentLatestConfigRequest(
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/configs/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentLatestConfigSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentLatestConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.AppComponentConfigConnection, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def create_terraform_module_component_config(
        self,
        *,
        security: Union[
            models.CreateTerraformModuleComponentConfigSecurity,
            models.CreateTerraformModuleComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        env_vars: Dict[str, str],
        variables: Dict[str, str],
        app_config_id: Optional[str] = None,
        checksum: Optional[str] = None,
        connected_github_vcs_config: Optional[
            Union[
                models.ServiceConnectedGithubVCSConfigRequest,
                models.ServiceConnectedGithubVCSConfigRequestTypedDict,
            ]
        ] = None,
        dependencies: Optional[List[str]] = None,
        public_git_vcs_config: Optional[
            Union[
                models.ServicePublicGitVCSConfigRequest,
                models.ServicePublicGitVCSConfigRequestTypedDict,
            ]
        ] = None,
        references: Optional[List[str]] = None,
        variables_files: Optional[List[str]] = None,
        version: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppTerraformModuleComponentConfig:
        r"""create a terraform component config

        Create a terraform component config.


        :param security:
        :param component_id: component ID
        :param env_vars:
        :param variables:
        :param app_config_id:
        :param checksum:
        :param connected_github_vcs_config:
        :param dependencies:
        :param public_git_vcs_config:
        :param references:
        :param variables_files:
        :param version:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateTerraformModuleComponentConfigRequest(
            component_id=component_id,
            service_create_terraform_module_component_config_request=models.ServiceCreateTerraformModuleComponentConfigRequest(
                app_config_id=app_config_id,
                checksum=checksum,
                connected_github_vcs_config=utils.get_pydantic_model(
                    connected_github_vcs_config,
                    Optional[models.ServiceConnectedGithubVCSConfigRequest],
                ),
                dependencies=dependencies,
                env_vars=env_vars,
                public_git_vcs_config=utils.get_pydantic_model(
                    public_git_vcs_config,
                    Optional[models.ServicePublicGitVCSConfigRequest],
                ),
                references=references,
                variables=variables,
                variables_files=variables_files,
                version=version,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/components/{component_id}/configs/terraform-module",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateTerraformModuleComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_terraform_module_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateTerraformModuleComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateTerraformModuleComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppTerraformModuleComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def create_terraform_module_component_config_async(
        self,
        *,
        security: Union[
            models.CreateTerraformModuleComponentConfigSecurity,
            models.CreateTerraformModuleComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        env_vars: Dict[str, str],
        variables: Dict[str, str],
        app_config_id: Optional[str] = None,
        checksum: Optional[str] = None,
        connected_github_vcs_config: Optional[
            Union[
                models.ServiceConnectedGithubVCSConfigRequest,
                models.ServiceConnectedGithubVCSConfigRequestTypedDict,
            ]
        ] = None,
        dependencies: Optional[List[str]] = None,
        public_git_vcs_config: Optional[
            Union[
                models.ServicePublicGitVCSConfigRequest,
                models.ServicePublicGitVCSConfigRequestTypedDict,
            ]
        ] = None,
        references: Optional[List[str]] = None,
        variables_files: Optional[List[str]] = None,
        version: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppTerraformModuleComponentConfig:
        r"""create a terraform component config

        Create a terraform component config.


        :param security:
        :param component_id: component ID
        :param env_vars:
        :param variables:
        :param app_config_id:
        :param checksum:
        :param connected_github_vcs_config:
        :param dependencies:
        :param public_git_vcs_config:
        :param references:
        :param variables_files:
        :param version:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateTerraformModuleComponentConfigRequest(
            component_id=component_id,
            service_create_terraform_module_component_config_request=models.ServiceCreateTerraformModuleComponentConfigRequest(
                app_config_id=app_config_id,
                checksum=checksum,
                connected_github_vcs_config=utils.get_pydantic_model(
                    connected_github_vcs_config,
                    Optional[models.ServiceConnectedGithubVCSConfigRequest],
                ),
                dependencies=dependencies,
                env_vars=env_vars,
                public_git_vcs_config=utils.get_pydantic_model(
                    public_git_vcs_config,
                    Optional[models.ServicePublicGitVCSConfigRequest],
                ),
                references=references,
                variables=variables,
                variables_files=variables_files,
                version=version,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/components/{component_id}/configs/terraform-module",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateTerraformModuleComponentConfigSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.service_create_terraform_module_component_config_request,
                False,
                False,
                "json",
                models.ServiceCreateTerraformModuleComponentConfigRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateTerraformModuleComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.AppTerraformModuleComponentConfig, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_config(
        self,
        *,
        security: Union[
            models.GetComponentConfigSecurity,
            models.GetComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        config_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentConfigConnection:
        r"""get all configs for a component

        :param security:
        :param component_id: component ID
        :param config_id: config ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentConfigRequest(
            component_id=component_id,
            config_id=config_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/configs/{config_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentConfigSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.AppComponentConfigConnection, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_config_async(
        self,
        *,
        security: Union[
            models.GetComponentConfigSecurity,
            models.GetComponentConfigSecurityTypedDict,
        ],
        component_id: str,
        config_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AppComponentConfigConnection:
        r"""get all configs for a component

        :param security:
        :param component_id: component ID
        :param config_id: config ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentConfigRequest(
            component_id=component_id,
            config_id=config_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/configs/{config_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentConfigSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentConfig",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.AppComponentConfigConnection, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_dependencies(
        self,
        *,
        security: Union[
            models.GetComponentDependenciesSecurity,
            models.GetComponentDependenciesSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponent]:
        r"""get a component's dependencies

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentDependenciesRequest(
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/dependencies",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentDependenciesSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentDependencies",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_dependencies_async(
        self,
        *,
        security: Union[
            models.GetComponentDependenciesSecurity,
            models.GetComponentDependenciesSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.AppComponent]:
        r"""get a component's dependencies

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentDependenciesRequest(
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/dependencies",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentDependenciesSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentDependencies",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(List[models.AppComponent], http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    def get_component_dependents(
        self,
        *,
        security: Union[
            models.GetComponentDependentsSecurity,
            models.GetComponentDependentsSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceComponentChildren:
        r"""get a component's children

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentDependentsRequest(
            component_id=component_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/components/{component_id}/dependents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentDependentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentDependents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ServiceComponentChildren, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)

    async def get_component_dependents_async(
        self,
        *,
        security: Union[
            models.GetComponentDependentsSecurity,
            models.GetComponentDependentsSecurityTypedDict,
        ],
        component_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ServiceComponentChildren:
        r"""get a component's children

        :param security:
        :param component_id: component ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComponentDependentsRequest(
            component_id=component_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/components/{component_id}/dependents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetComponentDependentsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetComponentDependents",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ServiceComponentChildren, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404"], "application/json"
        ):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                errors.StderrErrResponseErrorData, http_res
            )
            raise errors.StderrErrResponseError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.NuonDefaultError("API error occurred", http_res, http_res_text)

        raise errors.NuonDefaultError("Unexpected response received", http_res)
